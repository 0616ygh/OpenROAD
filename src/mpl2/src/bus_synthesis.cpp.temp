#include "bus_synthesis.h"

#include <iostream>
#include <queue>
#include <vector>
#include <limits>
#include <map>
#include <algorithm>
#include <set>
#include "object.h"

namespace mpl {

//////////////////////////////////////////////////////////////
// Class Graph
// Constructors
Graph::Graph(int num_vertices, float congestion_weight)
  : adj_(num_vertices), congestion_weight_(congestion_weight)  {   }

// Add an edge to the adjacency matrix
void Graph::AddEdge(int src, int dest, float weight, Edge* edge_ptr) 
{
  adj_[src].push_back(Arrow{dest, weight, edge_ptr});
  adj_[dest].push_back(Arrow{src, weight, edge_ptr});
}

// Find the shortest paths relative to root vertex based on priority queue 
// We store the paths in the format of parent vertices
// If we want to get real pathes, we need to traverse back the parent vertices
void Graph::CalShortPathParentVertices(int root) 
{
  // store the parent vertices for each vertex in the shortest paths
  // for example, there are two paths from root to dest
  // path1: root -> A -> dest
  // path2: root -> B -> dest
  // then dest vertex has two parents:  A and B 
  // So the parent of each vertex is a vector instead of some vertex
  std::vector<std::vector<int> > parent(adj_.size());
  // initialization
  // set the dist to infinity, store the dist of each vertex related to root vertex
  std::vector<float> dist(adj_.size(), std::numeric_limits<float>::max());
  // set all the vertices unvisited
  std::vector<bool> visited(adj_.size(), false);
  // initialize empty wavefront 
  // the class is VertexDist (vertex, dist to src)
  // std::vector<VertexDist> is the class container
  // VertexDistComparator is the comparator, the first lement is
  // the greatest one (with shortest distance to src)
  std::priority_queue<VertexDist, std::vector<VertexDist>, 
                      VertexDistComparator> wavefront;
  // initialize root vertex
  parent[root] = { -1 };  // set the parent of root vertex to { -1 }
  dist[root] = 0.0;
  wavefront.push(VertexDist{root, dist[root]});
  // Forward propagation
  while (wavefront.empty() == false) {
    VertexDist vertex_dist = wavefront.top();
    wavefront.pop();
    // check if the vertex has been visited
    // we may have a vertex with different distances in the wavefront   
    // only the shortest distance of the vertex should be used.
    if (visited[vertex_dist.vertex] == true)
      continue;
    // mark current vertex as visited
    visited[vertex_dist.vertex] = true;
    for (const auto& edge : adj_[vertex_dist.vertex]) {
      if (dist[edge.dest] > dist[vertex_dist.vertex] + edge.weight) {
        dist[edge.dest] = dist[vertex_dist.vertex] + edge.weight;
        parent[edge.dest].clear();
        parent[edge.dest].push_back(vertex_dist.vertex);
        wavefront.push(VertexDist{edge.dest, dist[edge.dest]});
      } else if (dist[edge.dest] == dist[vertex_dist.vertex] + edge.weight) {
        parent[edge.dest].push_back(vertex_dist.vertex);
      }
    } // done edge traversal
  } // done forward propagation
  parents_[root] = parent; // update parents map
};


// Find real paths between root vertex and target vertex
// by traversing back the parent vertices in a recursive manner
// Similar to DFS (not exactly DFS)
void Graph::CalShortPaths(
     // all paths between root vertex and target vertex
     std::vector<std::vector<int> >& paths, 
     // current path between root vertex and target vertex
     std::vector<int>& path,
     // vector of parent vertices for root vertex
     std::vector<std::vector<int> >& parent_vertices,
     // current parent vertex
     int parent)
{
  // Base case
  if (parent == -1) {
    paths.push_back(path);
    return;
  }
  // Recursive case
  for (const auto& ancestor : parent_vertices[parent]) {
    path.push_back(parent);
    // This step is necessary to avoid loops caused by the edge with zero weight
    if (std::find(path.begin(), path.end(), ancestor) == path.end())
      CalEdgePaths(paths, path, parent_vertices, ancestor);     
    path.pop_back();    
  }
}


// Calculate shortest edge paths
void Graph::CalEdgePaths(
        // shortest paths, path = { vertex_id }
        std::vector<std::vector<int> >& paths, 
        // shortest boundary edge paths
        std::vector<std::vector<int> >& edge_paths,
        // length of shortest paths
        float& HPWL)
{
  // map each edge in the adjacency matrix to edge_ptr
  std::vector<std::map<int, Edge*> > adj_map(adj_.size());   
  for (int i = 0; i < adj_.size(); i++)
    for (auto& arrow : adj_[i]) 
      adj_map[i][arrow.dest] = arrow.edge_ptr;
  // use sum(edge_id * edge_id) as hash value for each path   
  std::set<int>  path_hash_set;
  float distance = 0.0;
  std::vector<int> edge_path;
  int hash_value = 0;
  for (const auto& path : paths) {
    // convert path to edge_path
    edge_path.clear();
    hash_value = 0;
    for (int i = 0; i < path.size() - 1; i++) {
      Edge* edge_ptr = adj_map[path[i]][path[i+1]];
      distance += edge_ptr->length * (1 - congestion_weight_);
      distance += edge_ptr->length_w * congestion_weight_;
      if (edge_ptr->internal == false) {
        hash_value += edge_ptr->edge_id * edge_ptr->edge_id;
        edge_path.push_back(edge_ptr->edge_id);
      }
    }
    // add edge_path to edge_paths
    if (path_hash_set.find(hash_value) == path_hash_set.end()) {
      HPWL = distance;
      edge_paths.push_back(edge_path);
      path_hash_set.insert(hash_value);
    } // done edge_path
  } // done edge_paths
}

// Calculate shortest pathes in terms of boundary edges
void Graph::CalNetEdgePaths(BundledNet& net)
{
  // check if the parent vertices have been calculated
  if (parents_.find(net.src) == parents_.end())
    CalShortPathParentVertices(net.src); // calculate parent vertices
  // initialize an empty path
  std::vector<int> path;
  std::vector<std::vector<int> > paths;  // paths in vertex id
  CalShortPaths(paths, path, parents_[net.src], net.target); // pathes in vertex id
  CalEdgePaths(paths, net.edge_paths, net.HPWL); // pathes in edges
}


///////////////////////////////////////////////////////////////////////////////////
// Top level functions
void CreateGraph(std::vector<SoftMacro>& soft_macros, // placed soft macros
        const float outline_width,  // width of parent cluster
        const float outline_height, // height of parent cluster
        std::vector<int>& soft_macro_vertex_id, // store the vertex id for each soft macro
        std::vector<Edge>& edge_list,
        std::vector<Vertex>& vertex_list)
{
  // use the center point of each cluster to define hanan grid
  // we use floor function to reduce the complexity of hanan grid
  std::set<float> x_hanan_point;
  std::set<float> y_hanan_point;
  for (const auto& soft_macro : soft_macros)  {
    x_hanan_point.insert(std::floor(soft_macro.GetX() + soft_macro.GetWidth() / 2.0));
    y_hanan_point.insert(std::floor(soft_macro.GetY() + soft_macro.GetHeight() / 2.0));
  }
  std::vector<float> x_grid;
  std::vector<float> y_grid;
  // horizontal direction
  for (auto x : x_hanan_point)
    x_grid.push_back(x);
  // vertical direction
  for (auto y : y_hanan_point)
     y_grid.push_back(y);
  // hanan grids (each grid point cooresponding to a vertex)
  for (auto y : y_grid)
    for (auto x : x_grid)
      vertex_list.push_back(Vertex(vertex_list.size(), Point(x, y)));
  // identify all the vertices within soft macros
  int macro_id = 0;
  for (const auto& soft_macro : soft_macros) {
    const float lx = soft_macro.GetX();
    const float ly = soft_macro.GetY();
    const float ux = lx + soft_macro.GetWidth();
    const float uy = ly + soft_macro.GetHeight();
    Rect rect(lx, ly, ux, uy);
    // calculate the macro utilization of the soft macro
    float macro_util = soft_macro.GetMacroUtil();  
    // find the vertices within the soft macro
    int x_start = -1;
    int y_start = -1;
    int x_end   = -1;
    int y_end   = -1;
    GetVerticesInRect(x_grid, y_grid, rect, x_start, x_end, y_start, y_end);
    / 
 
 // Calculate shortest edge paths
/ set the weight for vertices within soft macros
    for (int y_idx = y_start; y_idx < y_end; y_idx++) {
      for (int x_idx = x_start; x_idx < x_end; x_idx++) {
        const int vertex_id = y_idx * x_grid.size() + x_idx;
        vertex_list[vertex_id].weight = macro_util;
        vertex_list[vertex_id].macro_id = macro_id;
      }
    }
    // increase macro id
    macro_id++;
  }
  // add all the horizontal edges 
  for (int y_idx = 0; y_idx < y_grid.size(); y_idx++) {
    for (int x_idx = 0; x_idx < x_grid.size() - 1; x_idx++) {
      const int src = y_idx * x_grid.size() + x_idx;
      const int target = src + 1;
      Edge edge_h(edge_list.size());
      edge_h.terminals = std::pair<int, int>(src, target);
      edge_h.direction = true;
      edge_h.length = x_grid[x_idx + 1] - x_grid[x_idx];
      edge_list.push_back(edge_h);
    }
  }
  // add the vertical edges
  for (int x_idx = 0; x_idx < x_grid.size(); x_idx++) {
    for (int y_idx = 0; y_idx < y_grid.size() - 1; y_idx++) {
      const int src = y_idx * x_grid.size() + x_idx;
      const int target = src + x_grid.size();
      Edge edge_v(edge_list.size());
      edge_v.terminals = std::pair<int, int>(src, target);
      edge_v.direction = false;
      edge_v.length = y_grid[y_idx + 1] - y_grid[y_idx];
      edge_list.push_back(edge_v);
    }
  }
  // determine if the edge is in a soft block
  // calculate the weighted wirelength
  for (auto& edge : edge_list) {
    auto& terminals = edge.terminals;
    const int target = terminals.first;
    const int src    = terminals.second;
    // assign internal flag
    if (vertex_list[src].macro_id != -1 &&
        vertex_list[src].macro_id == vertex_list[target].macro_id) 
      edge.internal = true;
    else
      edge.internal = false;
    // determine the weighted wirelength
    










  }








  

  
  
  // add edges within soft macros
  int macro_id = 0;
  for (const auto& soft_macro : soft_macros) {
    const float lx = soft_macro.GetX();
    const float ly = soft_macro.GetY();
    const float ux = lx + soft_macro.GetWidth();
    const float uy = ly + soft_macro.GetHeight();
    Rect rect(lx, ly, ux, uy);
    // calculate the macro utilization of the soft macro
    float macro_util = soft_macro.GetMacroUtil();  
    // find the vertices within the soft macro
    int x_start = -1;
    int y_start = -1;
    int x_end   = -1;
    int y_end   = -1;
    GetVerticesInRect(x_grid, y_grid, rect, x_start, x_end, y_start, y_end);
    // set the weight for vertices within soft macros
    for (int y_idx = y_start; y_idx < y_end; y_idx++) {
      for (int x_idx = x_start; x_idx < x_end; x_idx++) {
        const int vertex_id = y_idx * x_grid.size() + x_idx;
        vertex_list[vertex_id].weight = macro_util;
        vertex_list[vertex_id].macro_id = macro_id;
      }
    }
    // add horizontal edges between vertices in soft macros
    for (int y_idx = y_start; y_idx < y_end; y_idx++) {
      for (int x_idx = x_start; x_idx < x_end - 1; x_idx++) {
        const int src = y_idx * x_grid.size() + x_idx;
        const int target = src + 1;
        Edge edge_h(edge_list.size());
        edge_h.terminals = std::pair<int, int>(src, target);
        edge_h.direction = true;
        edge_h.weight = macro_util;
        edge_h.length = x_grid[x_idx + 1] - x_grid[x_idx];
        edge_h.length_w = macro_util * edge_h.length;
        edge_h.internal = true;
        edge_list.push_back(edge_h);
      }
    }
    // add vertical edges between vertices in soft macros
    for (int x_idx = x_start; x_idx < x_end; x_idx++) {
      for (int y_idx = y_start; y_idx < y_end - 1; y_idx++) {
        const int src = y_idx * x_grid.size() + x_idx;
        const int target = src + x_grid.size();
        Edge edge_v(edge_list.size());
        edge_v.terminals = std::pair<int, int>(src, target);
        edge_v.direction = false;
        edge_v.weight = macro_util;
        edge_v.length = y_grid[y_idx + 1] - y_grid[y_idx];
        edge_v.length_w = macro_util * edge_v.length;
        edge_v.internal = true;
        edge_list.push_back(edge_v);
      }
    }
    // increase macro id
    macro_id++;
  }
  
  // add edges between soft macros
  





}



// Calculate the paths for global buses with ILP
// congestion_weight : the cost for each edge is
// (1 - congestion_weight) * length + congestion_weight * length_w
void CalNetPaths(std::vector<SoftMacro>& soft_macros, // placed soft macros
                 std::vector<int>& soft_macro_vertex_id, // store the vertex id for each soft macro
                 std::vector<Edge>& edge_list,
                 std::vector<Vertex>& vertex_list,
                 std::vector<BundledNet>& nets,
                 // parameters
                 float congestion_weight)
{
  // create graph based on vertex list and edge list
  Graph graph(vertex_list.size(), congestion_weight);
  for (auto& edge : edge_list) {
    float weight = edge.length * (1 - congestion_weight) 
                   + edge.length_w * congestion_weight; // cal edge weight
    graph.AddEdge(edge.terminals.first, edge.terminals.second, weight, &edge);
  }
  // Find all the shortest paths based on graph
  int num_paths = 0;
  std::map<int, int> net_map; // path_id, net_id (this is used as a base to find a path in a net)
  std::map<int, int> net_path_map; // path_id, path_id of a net
  int net_id = 0;
  for (auto& net : net_list) {
    // calculate candidate paths
    graph.CalNetEdgePaths(net);
    // update path id
    int path_id = 0;
    for (const auto& edge_path : net.edge_paths) {
      net_map[num_paths] = net_id;
      net_path_map[num_paths++] = path_id++;
    }
    net_id++;
  }
  // Cal ILP Solver to solve the ILP problem
  IloEnv myenv;   // environment object
  IloModel mymodel(myenv);  // model object
  // For each path, define a variable x
  IloNumVarArray x(myenv, num_paths, 0, 1, ILOINT);
  // For each edge, define a variable y
  IloNumVarArray y(myenv, edge_list.size(), 0, 1, ILOINT);

  int x_id = 0;
  int num_constraints = 0;  // equal to number of nets
  for (auto& net : net_list) {
    IloExpr expr(myenv); // empty expression
    for (auto& edge_path : net.edge_paths) {
      for (auto& edge_id : edge_path) {
        mymodel.add(x[x_id] <= y[edge_id]);
        num_constraints++;
      }
      expr += x[x_id++];
    }
    mymodel.add(expr == 1);
    expr.end(); // clear memory
    num_constraints++;
  }
  
  IloExpr obj_expr(myenv);   // empty expression
  for (int i = 0; i < edge_list.size(); i++)
    obj_expr += edge_list[i].weight * y[i];
  mymodel.add(IloMinimize(myenv, obj_expr));  // adding minimization objective
  obj_expr.end();  // clear memory

  // Model Solution
  IloCplex mycplex(myenv);
  mycplex.extract(mymodel);
  mycplex.solve();

  // solves model and stores whether or 
  // not it is feasible in an IloBool variable called "feasible
  if (feasible != IloTrue) {
     std::cout << "[ERROR]  There is no feasible solution" << std::endl;
     return;
  }

  // Generate the solution and check which edge get selected
  for (int i = 0; i < edge_list.size(); i++) {
    if (mycplex.getValue(y[i]) == 1) {
     


    }
  }


   


  // closing the model
  mycplex.clear();
  myenv.end();
}








///////////////////////////////////////////////////////////////////////
// Utility Functions

// Get vertices within a given rectangle
// Calculate the start index and end index in the grid
void GetVerticesInRect(const std::vector<float>& x_grid,
                       const std::vector<float>& y_grid,
                       const Rect& rect,
                       int& x_start, int& x_end, int& y_start, int y_end) 
{
  GetVerticesInSegment(x_grid, rect.xMin(), rect.xMax(), x_start, x_end);
  GetVerticesInSegment(y_grid, rect.yMin(), rect.yMax(), y_start, y_end);
}

// Get vertices in a given segement
// We do not consider start terminal and end terminal
void GetVerticesInSegment(const std::vector<float>& grid,
                          const float start_point,
                          const float end_point,
                          int& start_idx, int& end_idx)
{
  start_idx = 0;
  end_idx   = 0;
  if (grid.size() == 0 || start_point >= end_point)
    return;
  // calculate start_idx
  while (start_idx < grid.size() &&
         grid[start_idx] <= start_point)
    start_idx++;
  // calculate end_idx
  while (end_idx < grid.size() &&
         grid[end_idx] >= end_point)
    end_idx++;
}












}


