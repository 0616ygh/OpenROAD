///////////////////////////////////////////////////////////////////////////////
// BSD 3-Clause License
//
// Copyright (c) 2021, The Regents of the University of California
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///////////////////////////////////////////////////////////////////////////////

#include "macro_placement.h"

#include <algorithm>
#include <cmath>
#include <fstream>
#include <random>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#include "util.h"
#include "odb/dbTypes.h"
#include "utl/Logger.h"
#include "db_sta/dbReadVerilog.hh"
#include "db_sta/dbSta.hh"
#include "odb/db.h"
#include "sta/Bfs.hh"
#include "sta/Graph.hh"
#include "sta/Liberty.hh"
#include "sta/Sta.hh"

namespace macro_placement {
using std::abs;
using std::cout;
using std::endl;
using std::exp;
using std::fstream;
using std::getline;
using std::ios;
using std::log;
using std::max;
using std::pair;
using std::pow;
using std::sort;
using std::stof;
using std::string;
using std::swap;
using std::thread;
using std::to_string;
using std::unordered_map;
using std::vector;
using utl::Logger;
using utl::MPL;


// Constructor
HardMacro::HardMacro(odb::dbInst* inst, float dbu) {
  inst_ = inst;
  dbu_  = dbu;
  
  // Set the position of virtual "pin"
  odb::Rect bbox;
  bbox.mergeInit();
  odb::dbMaster* master = inst->getMaster();
  for (odb::dbMTerm* mterm : master->getMTerms()) {
    if (mterm->getSigType() == odb::dbSigType::SIGNAL) {
      for (odb::dbMPin* mpin : mterm->getMPins()) {
        for (odb::dbBox* box : mpin->getGeometry()) {
          odb::Rect rect;
          box->getBox(rect);
          bbox.merge(rect);
        }
      }
    }
  }

  pin_x_ = (bbox.xMin() + bbox.xMax()) / (2 * dbu);
  pin_y_ = (bbox.yMin() + bbox.yMax()) / (2 * dbu);

  // Set the width and height
  width_ = master->getWidth() / dbu;
  height_ = master->getHeight() / dbu;

  // Set the name
  name_ = inst->getName();
}

bool HardMacro::operator<(const HardMacro& macro) const {
  if (width_ != macro.width_)
    return width_ < macro.width_;

  return height_ < macro.height_;
}

bool HardMacro::operator==(const HardMacro& macro) const {
  if (width_ == macro.width_ && height_ == macro.height_)
    return true;
  else
    return false;
}

void HardMacro::Flip(bool axis) {
  if (axis == true) {
    orientation_ = orientation_.flipY();
    pin_x_ = width_ - pin_x_;
  } else {
    orientation_ = orientation_.flipX();
    pin_y_ = height_ - pin_y_;
  }
}



// *********************************************************************
// Class SimulatedAnnealingCore
// *********************************************************************
template <class T>
SimulatedAnnealingCore<T>::SimulatedAnnealing(EngineType engine,
  // boundary constraints
  float outline_width,  float outline_height,  const std::vector<T>& macros, 
  // weight for different penalty
  float outline_weight, float wirelength_weight,  float boundary_weight,
  float notch_weight, float blockage_weight,  float guidance_weight,  float fence_weight,
  // probability of each action
  float resize_prob,  float pos_swap_prob, float neg_swap_prob,
  float double_swap_prob, float exchange_prob, float flip_prob,
  // Fast SA hyperparameter
  float init_prob, float rej_ratio, int max_num_step,
  int num_perturb_per_step,  int k,  int c, unsigned seed) {
  // initialization
  engine_ = engine;
  
  outline_width_  = outline_width;
  outline_height_ = outline_height;

  outline_weight_    = outline_weight;
  wirelength_weight_ = wirelength_weight;
  boundary_weight_   = boundary_weight;
  notch_weight_      = notch_weight;
  blockage_weight_   = blockage_weight;
  guidance_weight_   = guidance_weight;
  fence_weight_      = fence_weight;

  init_prob_         = init_prob;
  rej_ratio_         = rej_ratio; 
  max_num_step_      = max_num_step;
  num_perturb_per_step_ = num_perturb_per_step;
  k_ = k;
  c_ = c;

  resize_prob_      = resize_prob;
  pos_swap_prob_    = pos_swap_prob;
  neg_swap_prob_    = neg_swap_prob;
  double_swap_prob_ = double_swap_prob;
  exchange_prob_    = exchange_prob;
  flip_prob_        = flip_prob;
  
  // generate random
  std::mt19937 randGen(seed);
  generator_ = randGen;
  std::uniform_real_distribution<float> distribution(0.0, 1.0);
  distribution_ = distribution;
   
  // macros and nets
  macros_ = macros;
}

template <class T>
float SimulatedAnnealingCore<T>::CalNormCost(float outline_penalty,  
  float wirelength, float boundary_penalty, float notch_penalty,
  float blockage_penalty, float guidance_penalty, float fence_penalty) const {
  // initialize cost
  float cost = 0.0;
  if (norm_outline_penalty_ > 0.0)
    cost += outline_weight_ * outline_penalty / norm_outline_penalty_;
  if (norm_wirelength_ > 0.0)
    cost += wirelength_weight_ * wirelength / norm_wirelength_;
  if (norm_boundary_penalty_ > 0.0)
    cost += boundary_weight_ * boundary_penalty / norm_boundary_penalty_;
  if (norm_notch_penalty_ > 0.0)
    cost += notch_weight_ * notch_penalty / norm_notch_penalty_;
  if (norm_blockage_penalty_ > 0.0)
    cost += blockage_weight_ * blockage_penalty / norm_blockage_penalty_;
  if (norm_guidance_penalty_ > 0.0)
    cost += guidance_weight_ * guidance_penalty / norm_guidance_penalty_;
  if (norm_fence_penalty_ > 0.0)
    cost += fence_weight_ * fence_penalty / norm_fence_penalty_;
  return cost;
}


template <class T>
void SimulatedAnnealingCore<T>::CalPenalty() {
  this->CalOutlinePenalty();
  this->CalWirelength(); 
  this->CalBoundaryPenalty();
  this->CalNotchPenalty();
  this->CalBlockagePenalty();
  this->CalGuidancePenalty();
  this->CalFencePenalty();
}
        
    
template <class T>
void SimulatedAnnealingCore<T>::CalOutlinePenalty() {
  const float max_width = max(outline_width_, width_);
  const float max_height = max(outline_height_, height_);
  outline_penalty_ = max_width * max_height - outline_width_ * outline_height_;
}
 

template <class T>
void SimulatedAnnealingCore<T>::CalWirelength() {
  // Initialization
  wirelength_ = 0.0;
  // We do not consider wirelength during ShapeEngine
  if (engine_ == ShapeEngine):
      return;

  for (const auto& net : nets) {
    const float x1 = macros_[net.terminals.first].GetPinX();
    const float y1 = macros_[net.terminals.first].GetPinY();
    const float x2 = macros_[net.terminals.second].GetPinX();
    const float y2 = macros_[net.terminals.second].GetPinY();
    wirelength_ += net.weight * (std::abs(x2 - x1) + std::abs(y2 - y1));
  }
}
 
template <class T>
void SimulatedAnnealingCore<T>::CalBlockagePenalty() {
  // Initialization
  blockage_penalty_ = 0.0;
  // We do not consider BlockagePenalty during ShapeEngine
  if (engine_ == ShapeEngine):
      return;
  
  for (const auto& [id , bboxes] : blockages_) {
    const float macro_lx = macros_[id].GetX();
    const float macro_ly = macros_[id].GetY();
    const float macro_ux = macro_lx + macros_[id].GetWidth();
    const float macro_uy = macro_ly + macros_[id].GetHeight();
    for (const auto& bbox : boxes) {
      // If there are some overlap between the boxes
      if (ux > bbox.lx && lx < bbox.ux && uy > bbox.ly && ly < bbox.uy)
        const float width = std::min(ux, bbox.ux) - std::max(lx, bbox.lx);
        const float height = std::min(uy, bbox.uy) - std::max(ly, bbox.ly);
        blockage_penalty_ += width * height;
      } // end if
    } // end bbox for
  } // end blockage for
}


template <class T>
void SimulatedAnnealingCore<T>::CalFencePenalty() {
  // Initialization
  fence_penalty_ = 0.0;
  // We do not consider FencePenalty during ShapeEngine
  if (engine_ == ShapeEngine):
      return;
  
  for (const auto& [id , bbox] : fences_) {
    const float macro_lx = macros_[id].GetX();
    const float macro_ly = macros_[id].GetY();
    const float macro_ux = macro_lx + macros_[id].GetWidth();
    const float macro_uy = macro_ly + macros_[id].GetHeight();
    const float width = std::max(ux, bbox.ux) - std::min(lx, bbox.lx) - (bbox.ux - bbox.lx) ;
    const float height = std::max(uy, bbox.uy) - std::min(ly, bbox.ly) - (bbox.uy - bbox.ly);
    fence_penalty_ += width * height;
  } 
}


template <class T>
void SimulatedAnnealingCore<T>::CalGuidancePenalty() {
  // Initialization
  guidance_penalty_ = 0.0;
  // We do not consider FencePenalty during ShapeEngine
  if (engine_ == ShapeEngine):
      return;
  
  for (const auto& [id , bbox] : guides_) {
    const float macro_lx = macros_[id].GetX();
    const float macro_ly = macros_[id].GetY();
    const float macro_ux = macro_lx + macros_[id].GetWidth();
    const float macro_uy = macro_ly + macros_[id].GetHeight();
    // center to center distance
    const float width  = (macro_ux - macro_lx) + (bbox.ux - bbox.lx);
    const float height = (macro_uy - macro_ly) + (bbox.uy - bbox.ly);
    float x_dist = std::abs((macro_ux + macro_lx) / 2.0 - (bbox.ux + bbox.lx) / 2.0);
    float y_dist = std::abs((macro_uy + macro_ly) / 2.0 - (bbox.uy + bbox.ly) / 2.0);
    x_dist = x_dist - width > 0.0 ? x_dist - width : 0.0;
    y_dist = y_dist - height > 0.0 ? y_dist - height : 0.0;
    if (x_dist >= 0.0 && y_dist >= 0.0)
      guidance_penalty_ += min(x_dist, y_dist);
  } 
}


// We only push macro clusters to the boundaries
template <class T>
void SimulatedAnnealingCore<T>::CalBoundaryPenalty() {
  // Initialization
  boundary_penalty_ = 0.0;
 
  // We do not consider boundary penalty during ShapeEngine and PinAlignment
  if (engine_ == ShapeEngine || engine_ == PinAlignment):
    return;
  
  for (const auto& macro : macros_) {
    if (macro.IsMacroCluster() == true) {
      const float lx = macro.GetX();
      const float ly = macro.GetY();
      const float ux = lx + macro.GetWidth();
      const float uy = ly + macro.GetHeight();
      const float x_dist = std::min(lx, std::abs(outline_width_ - ux));
      const float y_dist = std::min(ly, std::abs(outline_height_ - uy));
      boundary_penalty_ += std::pow(std::min(x_dist, y_dist) * macro.GetNumMacros(), 2);
    }
  }
}
 

// Align macro clusters to boundaries
template <class T>
void SimulatedAnnealingCore<T>::AlignMacro() {
  // horizontal and vertical threshold for moving distances
  // set H_th (V_th) to the minimum width (height) of macro
  float H_th = outline_height_;
  float V_th = outline_width_;
  for (const auto& macro : macros_) {
    H_th = std::min(H_th, macro.GetHeight());
    V_th = std::min(V_th, macro.GetWidth());
  }

  // Align macros based on constraint graphs
  // The alignment step will not change the relative position 
  // of macros
  return;
}


// We only consider the notch penalty when there are only
// standard cell clusters and hard macro clusters
template <class T>
void SimulatedAnnealingCore<T>::CalNotchPenalty() {
  // Initialization
  notch_penalty_ = 0.0;
 
  // We do not consider boundary penalty during ShapeEngine and PinAlignment
  if (engine_ == ShapeEngine || engine_ == PinAlignment):
    return;
  
  for (const auto& macro : macros_) 
    if ((macro.GetNumMacros() > 0) && (macro.IsMacroCluster() == false))
      return;
  
  // If the floorplan cannot fit into the outline
  if (width_ > outline_width_ || height_ > outline_height_) {
    const float area = std::max(width_, outline_width_) * max(height_, outline_height_);
    notch_penalty_ = std::sqrt(area / (outline_width_ * outline_height_));
    return;
  }

  // If the macro can fit into the outline
  return;  
}
 

////////////////////////////////////////////////////////////////////
// Operations of Simulated Annealing
////////////////////////////////////////////////////////////////////

// Determine the positions of macros based on sequence pair
template <class T>
void SimulatedAnnealingCore<T>::PackFloorplan() {
  for (auto& macro : macros_) {
    macro.SetX(0.0);
    macro.SetY(0.0);
  }
   
  // calculate X position
  // store the position of each macro in the pos_seq_ and neg_seq_
  std::vector<std::pair<int, int> > match(macros_.size());
  for (int i = 0; i < macros_.size(); i++) {
    match[pos_seq_[i]].first = i;
    match[neg_seq_[i]].second = i;
  }

  // Initialize current length
  std::vector<float> length(macros_.size(), 0.0);
  for (int i = 0; i < pos_seq_.size(); i++) {
    const int b = pos_seq_[i]; // macro_id
    const int p = match[b].second; // the position of current macro in neg_seq_
    macros_[b].SetX(length[p]);
    const float t = macros_[b].GetX() + macros_[b].GetWidth(); 
    for (int j = p; j < neg_seq_.size(); j++)
      if (t > length[j])
        length[j] = t;
      else
        break;
  }

  // update width_ of current floorplan
  width_ = length[macros_.size() - 1];
 
  // calulate Y position
  std::vector<int> pos_seq(pos_seq_.size());
  for (int i = 0; i < macros_.size(); i++)
    pos_seq[i] = pos_seq_[macros_.size() - 1 - i];

  // store the position of each macro in the pos_seq_ and neg_seq_
  for (int i = 0; i < macros_.size(); i++) {
    match[pos_seq[i]].first = i;
    match[neg_seq_[i]].second = i;
    length[i] = 0.0; // initialize the length
  }

  for (int i = 0; i < pos_seq_.size(); i++) {
    const int b = pos_seq_[i]; // macro_id
    const int p = match[b].second; // the position of current macro in neg_seq_
    macros_[b].SetY(length[p]);
    const float t = macros_[b].GetY() + macros_[b].GetHeight(); 
    for (int j = p; j < neg_seq_.size(); j++)
      if (t > length[j])
        length[j] = t;
      else
        break;
  }

  // update width_ of current floorplan
  height_ = length[macros_.size() - 1];
}


// Perturb
template <class T>
void SimulatedAnnealingCore<T>::Perturb() {
  if (macros_.size() == 0)
    return;

  // Keep back up 
  pre_pos_seq_ = pos_seq_;
  pre_neg_seq_ = neg_seq_;

  pre_width_ = width_;
  pre_height_ = height_;
  pre_outline_penalty_  = outline_penalty_;
  pre_wirelength_       = wirelength_;
  pre_boundary_penalty_ = boundary_penalty_;
  pre_notch_penalty_    = notch_penalty_;
  pre_blockage_penalty_ = blockage_penalty_;
  pre_guidance_penalty_ = guidance_penalty_;
  pre_fence_penalty_    = fence_penalty_;

  // generate random number (0 - 1) to determine actions
  const float op = (distribution_) (generator_); 
  const float action_prob_0 = resize_prob_;
  const float action_prob_1 = action_prob_0 + pos_swap_prob_;
  const float action_prob_2 = action_prob_1 + neg_swap_prob_;
  const float action_prob_3 = action_prob_2 + double_swap_prob_;
  const float action_prob_4 = action_prob_3 + exchange_prob_;
  const float action_prob_5 = action_prob_4 + flip_prob_;

  if (op <= action_prob_0) {
    action_id_ = 0;
    // change the aspect ratio of SoftMacros
    pre_macros_ = macros_;
    ResizeSoftMacros();
  } else if (op <= action_prob_1) {
    action_id_ = 1;
    SingleSeqSwap(true); // Swap two macros in pos_seq_
  } else if (op <= action_prob_2) {
    action_id_ = 2;
    SingleSeqSwap(false); // Swap two macros in neg_seq_;
  } else if (op <= action_prob_3) {
    action_id_ = 3;
    DoubleSeqSwap(); // Swap two macros in pos_seq_ and other two macros in neg_seq_
  } else if (op <= action_prob_4) {
    action_id_ = 4;
    ExchangeMacros();  // exchange two macros in the sequence pair
  } else { 
    action_id_= 5;
    pre_macros_ = macros_;
    FlipMacro();      // Flip one macro
  }

  // update the macro locations based on Sequence Pair
  PackFloorplan();

  // Update all the penalties
  CalPenalty();
}



// Perturb
template <class T>
void SimulatedAnnealingCore<T>::Restore() {
  if (macros_.size() == 0)
    return;

  // To reduce the runtime, here we do not call PackFloorplan
  // again. So when we need to generate the final floorplan out,
  // we need to call PackFloorplan again at the end of SA process
  if (action_id_ == 0 && action_id_ == 5) 
    macros_[macro_id_] = pre_macros_[macro_id_];
  else if (action_id_ == 1)
    pos_seq_ = pre_pos_seq_;
  else if (action_id_ == 2)
    neg_seq_ = pre_neg_seq_;
  else {
    pos_seq_ = pre_pos_seq_;
    neg_seq_ = pre_neg_seq_;
  }

  width_  = pre_width_;
  height_ = pre_height_;
  outline_penalty_  = pre_outline_penalty_;
  wirelength_       = pre_wirelength_;
  boundary_penalty_ = pre_boundary_penalty_;
  notch_penalty_    = pre_notch_penalty_;
  blockage_penalty_ = pre_blockage_penalty_;
  guidance_penalty_ = pre_guidance_penalty_;
  fence_penalty_    = pre_fence_penalty_;
}


// ResizeSoftMacros
template <class T>
void SimulatedAnnealingCore<T>::ResizeSoftMacros() {
  ;
}
 
// SingleSeqSwap
template <class T>
void SimulatedAnnealingCore<T>::SingleSeqSwap(bool pos) {
  if (macros_.size() <= 1)
    return;
    
  const int index1 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  int index2 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  while (index1 == index2) {
    index2 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  }
   
  if (pos == true)
    std::swap(pos_seq_[index1], pos_seq_[index2]);
  else
    std::swap(neg_seq_[index1], neg_seq_[index2]);
}

// DoubleSeqSwap
template <class T>
void SimulatedAnnealingCore<T>::DoubleSeqSwap() {
  if (macros_.size() <= 1)
    return;
    
  const int index1 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  int index2 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  while (index1 == index2) {
    index2 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  }
   
  std::swap(pos_seq_[index1], pos_seq_[index2]);
  std::swap(neg_seq_[index1], neg_seq_[index2]);
}


// ExchaneMacros
template <class T>
void SimulatedAnnealingCore<T>::ExchangeMacros() {
  if (macros_.size() <= 1)
    return;
  
  // swap positive seq
  int index1 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  int index2 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  while (index1 == index2) {
    index2 = (int) (std::floor((distribution_) (generator_) * macros_.size()));
  }

  std::swap(pos_seq_[index1], pos_seq_[index2]);
  
  int neg_index1 = -1;
  int neg_index2 = -1;
  // swap negative seq
  for (int i = 0; i < macros_.size(); i++) {
    if (pos_seq_[index1] == neg_seq_[i])
      neg_index1 = i;
 
    if (pos_seq_[index2] == neg_seq_[i])
      neg_index2 = i;
  }
 
  std::swap(neg_seq_[neg_index1], neg_seq_[neg_index2]);
}


// FlipMacro
template <class T>
void SimulatedAnnealingCore<T>::FlipMacro() {
  std::vector<int> macro_vec;
  for (int i = 0; i < macros_.size(); i++)
    if (macros_[i].IsHardMacroCluster() == true && 
        macros_[i].GetNumMacros() == 1)
      macro_vec.push_back(i);

  // random choose a hard macro to flip
  macro_id_ = macro_vec[(int) (std::floor((distribution_) (generator_) * macro_vec.size()))];
  const float prob = (distribution_) (generator_);
  if (prob <= 0.5)
    macros_[macro_id_].Flip(true);
  else
    macros_[macro_id_].Flip(false);
}

template <class T>
float SimulatedAnnealingCore<T>::CalAverage(std::vector<float>& value_list) {
  float sum = 0.0;
  for (const auto& value : value_list)
    sum += value;

  return sum / value_list.size();
}


template <class T>
void SimulatedAnnealingCore<T>::Initialize() {
  std::vector<float> outline_penalty_list; 
  std::vector<float> wirelength_list;
  std::vector<float> boundary_penalty_list;
  std::vector<float> notch_penalty_list;
  std::vector<float> blockage_penalty_list;
  std::vector<float> guidance_penalty_list;
  std::vector<float> fence_penalty_list;
  
  for (int i = 0; i < num_perturb_per_step_; i++) {
    Perturb();
    // store current penalties 
    outline_penalty_list.push_back(outline_penalty_);
    wirelength_list.push_back(wirelength_);
    boundary_penalty_list.push_back(boundary_penalty_);
    notch_penalty_list.push_back(notch_penalty_);
    blockage_penalty_list.push_back(blockage_penalty_);
    gudiance_penalty_list.push_back(guidance_penalty_);
    fence_penalty_list.push_back(fence_penalty_);
  }

   
  norm_outline_penalty_  = CalAverage(outline_penalty_list);
  norm_wirelength_       = CalAverage(wirelength_list);
  norm_boundary_penalty_ = CalAverage(boundary_penalty_list);
  norm_notch_penalty_    = CalAverage(notch_penalty_list);
  norm_blockage_penalty_ = CalAverage(blockage_penalty_list);
  norm_guidance_penalty_ = CalAverage(guidance_penalty_list);
  norm_fence_penalty_    = CalAverage(fence_penalty_list);


  // Calculate initial temperature
  std::vector<float> cost_list;
  for (int i = 0; i < outline_penalty_list.size(); i++)
    cost_list.push_back(CalNormCost(outline_penalty_list[i], 
                                    wirelength_list[i],
                                    boundary_penalty_list[i],
                                    notch_penalty_list[i],
                                    blockage_penalty_list[i],
                                    guidance_penalty_list[i],
                                    fence_penalty_list[i]));
  float delta_cost = 0.0;
  for (int i = 1; i < cost_list.size(); i++)
    delta_cost += abs(cost_list[i] - cost_list[i - 1]);
  
  init_T_ = (-1.0) * (delta_cost / (cost_list.size() - 1)) / log(init_prob_);
}

template <class T>
void SimulatedAnnealingCore<T>::FastSA() {
  // record the previous status
  float cost = CalNormCost(outline_penalty_, wirelength_,
                           boundary_penalty_, notch_penalty_,
                           blockage_penalty_, guidance_penalty_,
                           fence_penalty_);
  float pre_cost = cost;
  float delta_cost = 0.0;
  int step = 1;
  // const for restart
  int num_restart = 1;
  const int max_num_restart = 2;
  
  while (step <= max_num_step_) {
    for (int i = 0; i < num_perturb_per_step_; i++) {
      Perturb();
      cost = CalNormCost(outline_penalty_, wirelength_,
                         boundary_penalty_, notch_penalty_,
                         blockage_penalty_, guidance_penalty_,
                         fence_penalty_);
      delta_cost = cost - pre_cost;
      const float num = distribution_(generator_);
      const float prob = (delta_cost > 0.0) ? exp((-1) * delta_cost / T) : 1;
      if (num < prob) 
        pre_cost = cost;   
      else 
        Restore();
    }

    if (step <= k_)
      T = init_T_ / (step * c_);
    else
      T = init_T_ / step;

    step++;

    // check if restart condition
    if ((num_restart <= max_num_restart) && (step == std::floor(max_num_step_ / max_num_restart) 
         && (outline_penalty_ > 0.0))) {
      num_restart++;
      step = 1;
      T = init_T_;
    }
  }

  PackFloorplan();
  CalPenalty();
}




////////////////////////////////////////////////////////////////////////
// HierRTLMP Class
////////////////////////////////////////////////////////////////////////

// Tile hard macros within each cluster to determine the possible shape
// for the cluster
std::vector<std::pair<float, float> > HierRTLMP::HardMacroTiling(
  std::vector<HardMacro>& hard_macros,
  float outline_width,
  float outline_height) {
  // tilings
  std::vector<std::pair<float, float> > tilings;

  // set the random seeds and factors for multi runs
  // We force SA worker to get different solutions by
  // changing the outline with a factor
  std::vector<unsigned> seed_list(num_runs_);
  std::vector<float>    factor_list(num_runs_);
  std::mt19937 rand_generator(seed_);
  for (int i = 0; i < num_runs_; i++) {
    seed_list[i] = (unsigned) rand_generator();
    factor_list[i] = 0.5 + i / num_runs_;
  }

  std::vector<SimulatedAnnealingCore<HardMacro>* > worker_list;

  // set the hyperparameters of SA worker
  const int num_perturb_per_step = hard_macros.size();
  // we don't perform any resize or flip in this stage
  const float resize_prob         = 0.0;
  const float flip_prob           = 0.0;
  float original_prob_sum = pos_swap_prob_ + neg_swap_prob_
                       + double_swap_prob_ + exchange_prob_;
  // new probability of each action
  const float pos_swap_prob = pos_swap_prob_ / original_prob_sum;
  const float neg_swap_prob = neg_swap_prob_ / original_prob_sum;
  const float double_swap_prob = double_swap_prob_ / original_prob_sum;
  const float exchange_prob    = exchange_prob_    / original_prob_sum;

  // new weight for each penalty
  // In this stage, we only cares about the outline penalty
  const float outline_weight    = 1.0;
  const float wirelength_weight = 0.0; 
  const float boundary_weight   = 0.0; 
  const float notch_weight      = 0.0;
  const float blockage_weight   = 0.0;
  const float guidance_weight   = 0.0;
  const float fence_weight      = 0.0;

  int remaining_runs = num_runs;
  int worker_id = 0;
  while (remaining_runs > 0) {
    int num_workers = num_threads_;
    if (remaining_runs < num_workers)
      num_workers = remaining_runs;

    // put each worker in parallel threads
    for (int i = 0; i < num_workers; i++) {
      const float temp_outline_width  = outline_width  * factor_list[work_id++];
      const float temp_outline_height = outline_height / factor_list[work_id++];
      SimualatedAnnealingCore<HardMacro>* worker = 
        new SimulatedAnnealingCore<HardMacro>(ShapeEngine,
            temp_outline_width, temp_outline_height, hard_macros,
            outline_weight,  wirelength_weight,  boundary_weight,
            notch_weight, blockage_weight, guidance_weight, fence_weight,
            resize_prob, pos_swap_prob, neg_swap_prob, double_swap_prob,
            exchange_prob, flip_prob,
            init_prob_, max_num_step_, num_perturb_per_step, k_,
            c_, seed_list[worker_id++]);
        
      worker_list.push_back(worker);
    }
   
    std::vector<std::thread> threads;
    for (auto& worker : worker_list)
      threads.push_back(std::thread(RunWorker, worker));

    for (auto& th : threads)
      th.join();

    // store the results
    for (auto& worker : worker_list) {
      std::pair<float, float> shape(worker->GetWidth(), worker->GetHeight());
      if (std::find_if(tilings.begin(), tilings.end(), PairCompare(shape))
          == tilings.end()))
        tilings.push_back(shape);
    }

    // delete the SA worker
    for (int i = 0; i < num_workers; i++)
      delete worker_list[i];
    worker_list.clear();

    remaining_runs -= num_workers;
  }

  return tilings;
}


// Convert each physical cluster to corresponding soft macros
// Then we can call macro placement to determine shapes, positions
// and pin access boundaries
SoftMacro HierRTLMP::Cluster2SoftMacro(par::Cluster* cluster) {
  const par::Metric metric = partitionMgr_->ComputeMetric(cluster);
  // inflat the size of standard cells 
  // This utilization can be a little higher than the real
  // utilization used by the floorplan
  const float std_cell_area = metric.std_cell_area / utilization_;
  float actual_area = std_cell_area; // the actual area of the cluster

  std::vector<HardMacro> hard_macros;
  for (auto& macro_inst : cluster->GetMacros()) {
    HardMacro hard_macro(macro_inst, dbu_);
    hard_macro.SetHaloWidth(halo_width_);
    // the macro area should include the halo width
    actual_area += hard_macro.GetArea();
    hard_macros.push_back(hard_macro);
  }

  std::vector<std::pair<float, float> > aspect_ratios;
  // Determine aspect ratio based on cluster type
  if (hard_macros.size() == 0) {
    // if the cluster is a standard-cell cluster
    aspect_ratios.push_back(std::pair<float, float>(
         min_aspect_ratio, max_aspect_ratio));
  } else {
    // if the cluster has macros
    // Here the outline_width and outline_height are the sizes of
    // parent cluster, since the parent cluster is the container
    float outline_width = cluster->GetParent()->GetWidth();
    float outline_height = cluster->GetParent()->GetHeight();
    // (width, height)
    std::vector<std::pair<float, float> > tilings 
      = HardMacroTiling(hard_macros, outline_width, outline_height);
    for (const auto& shape : tilings) {
      if (shape.first * shape.second <= actual_area &&
        shape.first <= outline_width &&
        shape.second <= outline_height) {
        // the macro tiling can be fit into the outline
        const float remaining_std_cell_area 
          = actual_area - shape.first * shape.seocnd;
        const float min_ar = shape.second / 
          (shape.first + remaining_std_cell_area / shape.second);
        const float max_ar = (shape.second + 
          remaining_std_cell_area / shape.first) / shape.first;
        aspect_ratios.push_back(std::pair<float, float>(min_ar, max_ar));
      }
    }

    // if no macro tiling can fit into the outline
    // pick the ones with minimum area
    if (aspect_ratios.size() == 0) {
      // find the minimum area
      float min_area = std::numeric_limits<float>::max();
      for (const auto& shape : tilings)
        if (shape.first <= outline_width && shape.second <= outline_height
            && shape.first * shape.second < min_area)
          min_area = shape.first * shape.second;

      // update the actual area
      actual_area = min_area;
      // feed the macro tilings into aspect ratios
      for (const auto& shape : tilings)
        if (shape.first <= outline_width && shape.second <= outline_height
            && shape.first * shape.second <= min_area)
            aspect_ratios.push_back(std::pair<float, float>(
              shape.second / shape.first, shape.second / shape.first));
    }

    // If there is no valid solution
    if (aspect_ratios.size() == 0)
      logger_->error(MPL, 1401, 
        "Cannot generate valid macro tilings for cluster : {}\n"
        "outline_width : {}\t\t outline_height : {}\n"
        "std_cell_area : {}\t\t actual_area : {}\n",
        cluster->GetName(), outline_width, 
        outline_height, std_cell_area, actual_area);
       
    // merge aspect ratios      
    std::sort(aspect_ratios.begin(), aspect_ratios.end(), SortPair);
    std::vector<std::pair<float, float> > merged_aspect_ratios;
    merged_aspect_ratios.push_back(aspect_ratios[0]);
    for (int i = 1; i < aspect_ratios.size(); i++) {
      float& pre_max_ar =
          merged_aspect_ratios[merged_aspect_ratios.size() - 1].second;
      const float& min_ar = aspect_ratios[i].first;
      const float& max_ar = aspect_ratios[i].second;
      // merge aspect ratio ranges if necessary
      if (min_ar > pre_max_ar)
        merged_aspect_ratios.push_back(aspect_ratios[i]);
      else if(min_ar < pre_max_ar && max_ar > pre_max_ar)
        pre_max_ar = max_ar;
    }

    aspect_ratios = merged_aspect_ratios;
  }
    
  // Create the corresponding soft macro
  SoftMacro soft_macro;
  SoftMacro.SetArea(actual_area);
  SoftMacro.SetAspectRatios(aspect_ratios);
    
  return SoftMacro;
}





}  // namespace macro_placement
