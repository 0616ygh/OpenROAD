/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2019, OpenROAD
// All rights reserved.
//
// BSD 3-Clause License
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////////

#include "rmp/blif.h"

#include <algorithm>
#include <fstream>
#include <iterator>
#include <map>
#include <streambuf>
#include <string>
#include <vector>

#include "ord/OpenRoad.hh"
#include "rmp/blifParser.h"
#include "utl/Logger.h"
#include "opendb/db.h"
#include "sta/Network.hh"
#include "sta/Liberty.hh"
#include "sta/FuncExpr.hh"
#include "db_sta/dbNetwork.hh"
#include "db_sta/dbSta.hh"

using utl::RMP;

namespace rmp {


blif::blif(ord::OpenRoad* openroad){
  openroad_ = openroad;
  logger_ = openroad->getLogger();
  openSta_ = openroad_->getSta();
}
bool blif::writeBlif(const char* fileName)
{
  int dummy_nets = 0;
  // Get Input + Output Nets
  FILE* f = fopen(fileName, "w");

  if (f == NULL) {
    logger_->error(RMP, 1, "cannot open file %s", fileName);
    return false;
  }

  std::set<odb::dbInst*>& insts = this->instancesToOptimize;
  std::map<uint, odb::dbInst*> instMap;
  std::vector<std::string> subckts;
  std::set<std::string> inputs, outputs, const0, const1;
  

  subckts.resize(insts.size());
  int instIndex = 0;

  for (auto&& inst : insts) {
    instMap.insert(std::pair<uint, odb::dbInst*>(inst->getId(), inst));
  }

  for (auto&& inst : insts) {
    auto master = inst->getMaster();
    auto masterName = master->getName();

    std::string currentSubckt = ".gate " + masterName;

    auto iterms = inst->getITerms();

    for (auto&& iterm : iterms) {
      auto mterm = iterm->getMTerm();
      auto net = iterm->getNet();

      if (iterm->getSigType() == odb::dbSigType::POWER
          || iterm->getSigType() == odb::dbSigType::GROUND)
        continue;

      auto mtermName = mterm->getName();
      auto netName = (net == NULL)? ("dummy_" + std::to_string(dummy_nets++)) : net->getName();

      currentSubckt += " " + mtermName + "=" + netName;

      if(net == NULL) continue;
      // check whether connected net is input/output
      // If it's only connected to one Iterm OR
      // It's connected to another instance that's outside the bubble
      auto connectedIterms = net->getITerms();

      if (connectedIterms.size() == 1) {
        if (iterm->getIoType() == odb::dbIoType::INPUT)
          inputs.insert(netName);
        else if (iterm->getIoType() == odb::dbIoType::OUTPUT)
          outputs.insert(netName);

      } else {
        bool addAsInput = false;
        for (auto&& connectedIterm : connectedIterms) {
          auto connectedInstId = connectedIterm->getInst()->getId();

          if (instMap.find(connectedInstId) == instMap.end()) {
            // Net is connected to an instance outside the cut out region
            // Check whether it's input or output
            if (iterm->getIoType() == odb::dbIoType::INPUT){
              // Net is connected to a pin outside the bubble and should be treated as an input
              // If the driving pin is contant then we'll add a constant gate in blif 
              // otherwise just add the net as input 
              auto pin_ = openSta_->getDbNetwork()->dbToSta(connectedIterm);
              auto network_ = openSta_->network();
              auto port_ = network_->libertyPort(pin_);

              if(port_){
                auto expr = port_->function();
                if (expr
                // Tristate outputs do not force the output to be constant.
                && port_->tristateEnable() == nullptr
                && (expr->op() == sta::FuncExpr::op_zero
                    || expr->op() == sta::FuncExpr::op_one)){
                      
                      if(expr->op() == sta::FuncExpr::op_zero) const0.insert(netName);
                      else const1.insert(netName);
                      
                  }else {
                    addAsInput = true;
                  }
              }else {
                addAsInput = true;
              }
              
            }
            else if (iterm->getIoType() == odb::dbIoType::OUTPUT)
              outputs.insert(netName);
          }
        }
        if (addAsInput && const0.find(netName) == const0.end() && const1.find(netName) == const1.end())
          inputs.insert(netName);
      }

      if (net->getSigType() == odb::dbSigType::POWER)
        const1.insert(netName);
      else if (net->getSigType() == odb::dbSigType::GROUND)
        const0.insert(netName);

      // connect to original ports if not inferred already
      if (inputs.find(netName) == inputs.end() && outputs.find(netName) == outputs.end()
          && const0.find(netName) == const0.end() && const1.find(netName) == const1.end()) {
        auto connectedPorts = net->getBTerms();
        for (auto connectedPort : connectedPorts) {
          if (connectedPort->getIoType() == odb::dbIoType::INPUT) {
              auto pin_ = openSta_->getDbNetwork()->dbToSta(connectedPort);
              auto network_ = openSta_->network();
              auto port_ = network_->libertyPort(pin_);

              if(port_){
                auto expr = port_->function();
                if (expr
                // Tristate outputs do not force the output to be constant.
                && port_->tristateEnable() == nullptr
                && (expr->op() == sta::FuncExpr::op_zero
                    || expr->op() == sta::FuncExpr::op_one)){

                      if(expr->op() == sta::FuncExpr::op_zero) const0.insert(netName);
                      else const1.insert(netName);

                  }else {
                    inputs.insert(netName);
                  }
              }else {
                inputs.insert(netName);
              }
          } else if (connectedPort->getIoType() == odb::dbIoType::OUTPUT) {
            outputs.insert(netName);
          }
        }
      }
    }
    subckts[instIndex++] = currentSubckt;
  }

  // remove drivers from input list
  std::vector<std::string> common_ports;
  set_intersection(inputs.begin(),
                   inputs.end(),
                   outputs.begin(),
                   outputs.end(),
                   std::back_inserter(common_ports));

  for (auto&& port : common_ports) {
    inputs.erase(port);
  }

  fwrite(
      ".model tmp_circuit\n", sizeof(char), strlen(".model tmp_circuit\n"), f);
  fwrite(".inputs", sizeof(char), strlen(".inputs"), f);
  for (auto& input : inputs) {
    if(const0.find(input) != const0.end() || const1.find(input) != const1.end()) continue;
    fwrite(" ", sizeof(char), strlen(" "), f);
    fwrite(input.c_str(), sizeof(char), input.size(), f);
  }
  fwrite("\n", sizeof(char), 1, f);

  fwrite(".outputs", sizeof(char), strlen(".outputs"), f);
  for (auto& output : outputs) {
    fwrite(" ", sizeof(char), strlen(" "), f);
    fwrite(output.c_str(), sizeof(char), output.size(), f);
  }
  fwrite("\n", sizeof(char), 1, f);
  fwrite("\n", sizeof(char), 1, f);

  for (auto& zero : const0){
    std::string const_subctk = ".gate _const0_ z=" + zero;
    fwrite(const_subctk.c_str(), sizeof(char), const_subctk.size(), f);
    fwrite("\n", sizeof(char), 1, f);
  }

  for (auto& one : const1){
    std::string const_subctk = ".gate _const1_ z=" + one;
    fwrite(const_subctk.c_str(), sizeof(char), const_subctk.size(), f);
    fwrite("\n", sizeof(char), 1, f);
  }


  for (auto& subckt : subckts) {
    fwrite(subckt.c_str(), sizeof(char), subckt.size(), f);
    fwrite("\n", sizeof(char), 1, f);
  }

  fwrite(".end", sizeof(char), strlen(".end"), f);

  fclose(f);
  return true;
}

void preprocessString(std::string& s)
{
  int ind, old_ind = -1;

  while ((ind = s.find("\n", old_ind + 1)) != std::string::npos) {
    if (s[old_ind + 1] == '#') {
      s.erase(old_ind + 1, ind - old_ind);
    }
    old_ind = ind;
  }
}

bool blif::inspectBlif(const char* fileName, int& numInstances){
  std::ifstream f(fileName);
  if (f.bad()) {
    logger_->error(RMP, 1, "cannot open file %s", fileName);
    return false;
  }

  std::string fileString((std::istreambuf_iterator<char>(f)),
                         std::istreambuf_iterator<char>());

  // Remove Comment Lines from Blif
  preprocessString(fileString);

  BlifParser blif;

  bool isValid = blif.parse(fileString);

  if(isValid) numInstances = blif.getGates().size();
  return isValid;
}

bool blif::readBlif(const char* fileName, odb::dbBlock* block)
{
  std::ifstream f(fileName);
  if (f.bad()) {
    logger_->error(RMP, 1, "cannot open file %s", fileName);
    return false;
  }

  std::string fileString((std::istreambuf_iterator<char>(f)),
                         std::istreambuf_iterator<char>());

  // Remove Comment Lines from Blif
  preprocessString(fileString);

  BlifParser blif;

  bool isValid = blif.parse(fileString);

  if (isValid) {
    // Remove and disconnect old instances
    logger_->info(RMP, 1, "blif parsed successfully, destroying {} existing instances...", instancesToOptimize.size());
    for (auto& inst : instancesToOptimize) {
      odb::dbInst::destroy(inst);
    }

    // Create and connect new instances
    auto gates = blif.getGates();
    logger_->info(RMP, 1, "inserting {} new instances...", gates.size());
    std::map<std::string, int> instIds;
    for (auto&& gate : gates) {
      std::string masterName = gate.first;
      std::vector<std::string> connections = gate.second;

      odb::dbMaster* master;

      for (auto &&lib : block->getDb()->getLibs())
      {
        master = lib->findMaster(masterName.c_str());
        if(master != NULL) break;
      }
      int constType = -1;
      if (master == NULL) {
        if (!strcmp("_const0_", masterName.c_str()))
          constType = 0;
        else if (!strcmp("_const1_", masterName.c_str()))
          constType = 1;
        else        
          logger_->warn(RMP, 1,
              "Master (%s) not found while stitching back instances\n",
              masterName.c_str());
        //return false;
        //continue;
      }

      instIds[masterName] = (instIds[masterName]) ? instIds[masterName] + 1 : 1;
      std::string instName
          = masterName + "_" + std::to_string(instIds[masterName]);
      odb::dbInst* newInst = nullptr;
      if (constType < 0)
        newInst = odb::dbInst::create(block, master, instName.c_str());

      for (auto&& connection : connections) {
        auto equalSignPos = connection.find("=");
        if (equalSignPos == std::string::npos)
          continue;
        auto mtermName = connection.substr(0, equalSignPos);
        auto netName = connection.substr(equalSignPos + 1);

        odb::dbNet* net = odb::dbNet::getValidNet(block, netName.c_str());
        if (net == NULL)
          net = odb::dbNet::create(block, netName.c_str());
        
        if (constType < 0)
          odb::dbITerm::connect(newInst->findITerm(mtermName.c_str()), net);
        else {
          logger_->report("Converting net constant {}", net->getName());
          for (auto iterm : net->getITerms()) {
            odb::dbInst* dbFF = iterm->getInst();
            sta::LibertyCell* libCell = openSta_->getDbNetwork()->libertyCell(dbFF);
            if (libCell->hasSequentials())
              logger_->report("..connected to inst {} cell {}", dbFF->getName(), libCell->name());

          }
          if (constType == 0)
            net->setSigType(odb::dbSigType::GROUND);
          else
            net->setSigType(odb::dbSigType::POWER);
        }
      }
    }
  }

  return true;
}

}  // namespace rmp
